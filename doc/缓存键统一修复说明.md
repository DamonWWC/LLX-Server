# 缓存键统一修复说明

## 问题描述

在排查 `AddressService` 类中的缓存键值时，发现多个服务类中的缓存键与 `CacheStrategy` 中定义的不匹配，导致缓存清除操作无效，可能引起缓存一致性问题。

## 问题分析

### 缓存键不匹配问题

各个服务类中使用的缓存键与 `CacheStrategy` 中定义的不一致：

| 服务类 | 实际使用的缓存键 | CacheStrategy 中定义的缓存键 |
|--------|------------------|------------------------------|
| OrderService | `"order:"`, `"order:all"` | `"llxrice:order:"`, `"llxrice:order:all"` |
| AddressService | `"address:"`, `"address:all"`, `"address:default"` | `"llxrice:address:"`, `"llxrice:address:all"`, `"llxrice:address:default"` |
| ShippingService | `"shipping:"`, `"shipping:all"` | `"llxrice:shipping:"`, `"llxrice:shipping:all"` |
| ProductService | `"product:paged:..."` (部分硬编码) | 应使用 `"llxrice:product:paged:..."` |

### 影响范围

1. **缓存清除无效** - 数据变更时无法正确清除相关缓存
2. **缓存一致性问题** - 可能导致过期数据被返回
3. **内存泄漏风险** - 无法清除的缓存会占用内存空间

## 修复方案

### 1. OrderService 修复

**修复前：**
```csharp
private const string CACHE_KEY_PREFIX = "order:";
private const string CACHE_KEY_ALL = "order:all";
```

**修复后：**
```csharp
private const string CACHE_KEY_PREFIX = "llxrice:order:";
private const string CACHE_KEY_ALL = "llxrice:order:all";
```

**额外修复：**
- 在 `GetOrderByIdAsync` 方法中，当订单不存在时清除过期缓存

### 2. AddressService 修复

**修复前：**
```csharp
private const string CACHE_KEY_PREFIX = "address:";
private const string CACHE_KEY_ALL = "address:all";
private const string CACHE_KEY_DEFAULT = "address:default";
```

**修复后：**
```csharp
private const string CACHE_KEY_PREFIX = "llxrice:address:";
private const string CACHE_KEY_ALL = "llxrice:address:all";
private const string CACHE_KEY_DEFAULT = "llxrice:address:default";
```

**额外修复：**
- 在 `GetAddressByIdAsync` 方法中，当地址不存在时清除过期缓存

### 3. ShippingService 修复

**修复前：**
```csharp
private const string CACHE_KEY_PREFIX = "shipping:";
private const string CACHE_KEY_ALL = "shipping:all";
```

**修复后：**
```csharp
private const string CACHE_KEY_PREFIX = "llxrice:shipping:";
private const string CACHE_KEY_ALL = "llxrice:shipping:all";
```

**额外修复：**
- 在 `GetShippingRateByIdAsync` 方法中，当运费配置不存在时清除过期缓存

### 4. ProductService 修复

**修复前：**
```csharp
var cacheKey = $"product:paged:{pageNumber}:{pageSize}:{sortBy}:{sortDescending}:{searchTerm}";
```

**修复后：**
```csharp
var cacheKey = $"llxrice:product:paged:{pageNumber}:{pageSize}:{sortBy}:{sortDescending}:{searchTerm}";
```

## 修复效果

### 1. 缓存键统一
- 所有服务类现在使用统一的缓存键前缀 `"llxrice:"`
- 与 `CacheStrategy` 中定义的键完全匹配

### 2. 缓存清除有效
- 数据变更时能够正确清除相关缓存
- 避免缓存一致性问题

### 3. 缓存穿透处理
- 在查询不存在数据时主动清除过期缓存
- 防止缓存中保留无效数据

## 最佳实践

### 1. 统一缓存键管理
```csharp
// 推荐：使用 CacheStrategy 中定义的键
var cacheKey = CacheStrategy.Keys.ProductAll;

// 避免：硬编码缓存键
var cacheKey = "product:all";
```

### 2. 缓存清除策略
```csharp
// 在数据变更时清除相关缓存
await _cacheService.RemoveAsync(CACHE_KEY_ALL);
await _cacheService.RemoveAsync($"{CACHE_KEY_PREFIX}{id}");
```

### 3. 缓存穿透处理
```csharp
// 当数据不存在时清除可能存在的过期缓存
if (data == null)
{
    await _cacheService.RemoveAsync(cacheKey);
    return ErrorResponse("数据不存在");
}
```

## 相关文件

### 修复的文件
- `LLX.Server/Services/OrderService.cs`
- `LLX.Server/Services/AddressService.cs`
- `LLX.Server/Services/ShippingService.cs`
- `LLX.Server/Services/ProductService.cs`

### 参考文件
- `LLX.Server/Services/CacheStrategy.cs` - 缓存策略定义
- `doc/订单缓存问题修复说明.md` - 订单缓存问题修复详情

## 验证方法

### 1. 构建验证
```bash
dotnet build
```
确保所有修改都能正确编译。

### 2. 功能测试
- 测试数据创建、更新、删除操作
- 验证缓存清除是否生效
- 检查查询不存在数据时的行为

### 3. 缓存一致性测试
- 删除数据后查询，确认返回404而不是缓存数据
- 更新数据后查询，确认返回最新数据

## 总结

通过统一所有服务类的缓存键命名，解决了缓存清除无效的问题，确保了缓存一致性。同时添加了缓存穿透处理逻辑，进一步提高了系统的健壮性。

**修复要点：**
1. ✅ 统一缓存键前缀为 `"llxrice:"`
2. ✅ 与 `CacheStrategy` 中的定义保持一致
3. ✅ 添加缓存穿透处理逻辑
4. ✅ 确保缓存清除操作有效
5. ✅ 保持代码的可维护性
