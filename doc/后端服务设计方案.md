# 林龍香大米商城 - 后端服务完整设计方案

## 📋 目录

1. [系统架构设计](#系统架构设计)
2. [技术栈说明](#技术栈说明)
3. [数据库设计](#数据库设计)
4. [API接口设计](#api接口设计)
5. [项目结构](#项目结构)
6. [核心代码实现](#核心代码实现)
7. [Redis缓存策略](#redis缓存策略)
8. [部署方案](#部署方案)
9. [开发规范](#开发规范)
10. [小程序对接说明](#小程序对接说明)

---

## 系统架构设计

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        微信小程序客户端                       │
│    (pages/index, checkout, orders, address, shipping)        │
└──────────────────────┬──────────────────────────────────────┘
                       │ HTTPS (443)
                       │ API 请求
┌──────────────────────▼──────────────────────────────────────┐
│                    Nginx 反向代理层                          │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  - HTTPS/SSL 终止                                    │   │
│  │  - 负载均衡                                          │   │
│  │  - 静态资源服务                                      │   │
│  │  - 请求限流                                          │   │
│  │  - Gzip 压缩                                         │   │
│  │  - 访问日志                                          │   │
│  └──────────────────────────────────────────────────────┘   │
└──────────────────────┬──────────────────────────────────────┘
                       │ HTTP (8080)
                       │ 内部转发
┌──────────────────────▼──────────────────────────────────────┐
│                .NET 8 Minimal API 层                         │
│  ┌──────────────┬──────────────┬──────────────────────────┐ │
│  │   Endpoints  │   Services   │   Repositories           │ │
│  │  (路由端点)   │  (业务逻辑)  │  (数据访问)              │ │
│  └──────────────┴──────────────┴──────────────────────────┘ │
└────────┬─────────────────────────────────────────┬──────────┘
         │                                         │
         │ EF Core                                 │ StackExchange.Redis
         │                                         │
┌────────▼────────────────────┐     ┌─────────────▼──────────┐
│   PostgreSQL 数据库          │     │    Redis 缓存服务       │
│  ┌──────────┬──────────┐    │     │  - 商品列表缓存         │
│  │ Products │ Orders   │    │     │  - 运费配置缓存         │
│  │ Addresses│ Shipping │    │     │  - 会话缓存(预留)       │
│  └──────────┴──────────┘    │     └────────────────────────┘
└─────────────────────────────┘
```

### 架构特点

- **Nginx 反向代理**: HTTPS 终止、负载均衡、请求限流、静态资源服务
- **Minimal API**: 使用 .NET 8 最小 API，代码简洁高效
- **分层架构**: Endpoints → Services → Repositories，职责清晰
- **缓存优化**: Redis 缓存热点数据，提升性能
- **无状态设计**: API 无状态，便于横向扩展
- **容器化部署**: Docker 一键部署，环境一致性好

### Nginx 反向代理功能

#### 1. HTTPS/SSL 终止
- 在 Nginx 层处理 HTTPS 加密/解密
- 后端 API 使用 HTTP，简化配置
- 支持自动续期 SSL 证书（Let's Encrypt）

#### 2. 负载均衡
- 支持多个后端实例
- 轮询、IP Hash、最少连接等策略
- 健康检查，自动剔除故障节点

#### 3. 静态资源服务
- 直接服务静态文件（如图片、文档）
- 减轻后端压力
- 支持浏览器缓存

#### 4. 请求限流
- 防止 DDoS 攻击
- 限制单 IP 请求频率
- 保护后端服务稳定性

#### 5. Gzip 压缩
- 压缩响应内容
- 减少网络传输量
- 提升响应速度

#### 6. 访问日志
- 记录所有请求
- 便于问题排查
- 支持日志分析

---

## 技术栈说明

### 后端技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| Nginx | 1.24+ | 反向代理、负载均衡、HTTPS |
| .NET | 8.0 | 后端框架 |
| ASP.NET Core | 8.0 | Web API 框架 |
| Entity Framework Core | 8.0 | ORM 框架 |
| PostgreSQL | 16 | 关系数据库 |
| Npgsql | 8.0 | PostgreSQL 驱动 |
| Redis | 7.2 | 缓存服务 |
| StackExchange.Redis | 2.7 | Redis 客户端 |
| Serilog | 3.1 | 结构化日志 |
| Swagger/OpenAPI | 6.5 | API 文档 |
| Docker | 24.0+ | 容器化部署 |
| Docker Compose | 2.20+ | 容器编排 |

### 为什么选择这些技术？

#### 1. Nginx
- ✅ **高性能**: 处理高并发请求，资源消耗低
- ✅ **成熟稳定**: 全球最流行的 Web 服务器之一
- ✅ **功能丰富**: 反向代理、负载均衡、SSL、缓存
- ✅ **易于配置**: 配置文件简洁，学习成本低

#### 2. .NET 8 Minimal API
- ✅ **性能优异**: 比传统 Controller 性能提升 20%+
- ✅ **代码简洁**: 减少样板代码，开发效率高
- ✅ **原生支持**: 微软官方推荐的轻量级 API 方案
- ✅ **易于扩展**: 支持中间件、过滤器等高级功能

#### 3. PostgreSQL
- ✅ **开源免费**: 完全开源，无版权问题
- ✅ **性能强大**: 支持高并发，事务处理能力强
- ✅ **功能丰富**: 支持 JSON、全文搜索等高级特性
- ✅ **跨平台**: 支持 Linux/Windows/macOS

#### 4. Redis
- ✅ **高性能**: 内存存储，读写速度快
- ✅ **数据结构丰富**: 支持 String、Hash、List、Set 等
- ✅ **持久化**: 支持 RDB 和 AOF 两种持久化方式
- ✅ **分布式支持**: 支持主从复制、集群模式

---

## 数据库设计

### ER 图

```
┌─────────────────┐         ┌─────────────────┐
│   Products      │         │   Addresses     │
│─────────────────│         │─────────────────│
│ Id (PK)         │         │ Id (PK)         │
│ Name            │         │ Name            │
│ Price           │         │ Phone           │
│ Unit            │         │ Province        │
│ Weight          │         │ City            │
│ Image           │         │ District        │
│ Quantity        │         │ Detail          │
│ CreatedAt       │         │ IsDefault       │
│ UpdatedAt       │         │ CreatedAt       │
└────────┬────────┘         │ UpdatedAt       │
         │                  └────────┬────────┘
         │                           │
         │   ┌─────────────────┐    │
         └───│   Orders        │────┘
             │─────────────────│
             │ Id (PK)         │
             │ OrderNo         │
             │ AddressId (FK)  │
             │ TotalRicePrice  │
             │ TotalWeight     │
             │ ShippingRate    │
             │ TotalShipping   │
             │ GrandTotal      │
             │ PaymentStatus   │
             │ Status          │
             │ CreatedAt       │
             │ UpdatedAt       │
             └────────┬────────┘
                      │ 1:N
             ┌────────▼────────┐
             │   OrderItems    │
             │─────────────────│
             │ Id (PK)         │
             │ OrderId (FK)    │
             │ ProductId (FK)  │
             │ ProductName     │
             │ ProductPrice    │
             │ ProductUnit     │
             │ ProductWeight   │
             │ Quantity        │
             │ Subtotal        │
             └─────────────────┘

┌─────────────────┐
│ ShippingRates   │
│─────────────────│
│ Id (PK)         │
│ Province        │
│ Rate            │
│ CreatedAt       │
│ UpdatedAt       │
└─────────────────┘
```

### 表结构说明

#### 1. Products（商品表）

```sql
CREATE TABLE "Products" (
    "Id" SERIAL PRIMARY KEY,
    "Name" VARCHAR(100) NOT NULL,
    "Price" DECIMAL(10,2) NOT NULL,
    "Unit" VARCHAR(20) NOT NULL,
    "Weight" DECIMAL(10,2) NOT NULL,
    "Image" TEXT,
    "Quantity" INT DEFAULT 0,
    "CreatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "UpdatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX "idx_products_name" ON "Products"("Name");
```

**字段说明**:
- `Name`: 商品名称，如"稻花香"、"长粒香"
- `Price`: 单价（元）
- `Unit`: 单位（袋/箱）
- `Weight`: 单位重量（斤）
- `Image`: 商品图片（Base64 或 URL）
- `Quantity`: 库存数量（暂未使用，预留）

#### 2. Addresses（收货地址表）

```sql
CREATE TABLE "Addresses" (
    "Id" SERIAL PRIMARY KEY,
    "Name" VARCHAR(50) NOT NULL,
    "Phone" VARCHAR(20) NOT NULL,
    "Province" VARCHAR(50) NOT NULL,
    "City" VARCHAR(50) NOT NULL,
    "District" VARCHAR(50),
    "Detail" VARCHAR(200) NOT NULL,
    "IsDefault" BOOLEAN DEFAULT FALSE,
    "CreatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "UpdatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX "idx_addresses_default" ON "Addresses"("IsDefault");
CREATE INDEX "idx_addresses_phone" ON "Addresses"("Phone");
```

**字段说明**:
- `IsDefault`: 是否默认地址

#### 3. Orders（订单表）

```sql
CREATE TABLE "Orders" (
    "Id" SERIAL PRIMARY KEY,
    "OrderNo" VARCHAR(50) UNIQUE NOT NULL,
    "AddressId" INT NOT NULL,
    "TotalRicePrice" DECIMAL(10,2) NOT NULL,
    "TotalWeight" DECIMAL(10,2) NOT NULL,
    "ShippingRate" DECIMAL(10,2) NOT NULL,
    "TotalShipping" DECIMAL(10,2) NOT NULL,
    "GrandTotal" DECIMAL(10,2) NOT NULL,
    "PaymentStatus" VARCHAR(20) DEFAULT '未付款',
    "Status" VARCHAR(20) NOT NULL DEFAULT '待发货',
    "CreatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "UpdatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT "fk_orders_address" FOREIGN KEY ("AddressId") 
        REFERENCES "Addresses"("Id") ON DELETE RESTRICT
);

CREATE INDEX "idx_orders_orderno" ON "Orders"("OrderNo");
CREATE INDEX "idx_orders_status" ON "Orders"("Status");
CREATE INDEX "idx_orders_createdat" ON "Orders"("CreatedAt" DESC);
```

**字段说明**:
- `OrderNo`: 订单号，格式: ORD + 时间戳
- `TotalRicePrice`: 商品总价
- `TotalWeight`: 总重量（斤）
- `ShippingRate`: 运费单价（元/斤）
- `TotalShipping`: 运费总计
- `GrandTotal`: 订单总金额
- `PaymentStatus`: 付款状态（已付款/未付款）
- `Status`: 订单状态（待付款/待发货/已发货/已完成/已取消）

#### 4. OrderItems（订单明细表）

```sql
CREATE TABLE "OrderItems" (
    "Id" SERIAL PRIMARY KEY,
    "OrderId" INT NOT NULL,
    "ProductId" INT NOT NULL,
    "ProductName" VARCHAR(100) NOT NULL,
    "ProductPrice" DECIMAL(10,2) NOT NULL,
    "ProductUnit" VARCHAR(20) NOT NULL,
    "ProductWeight" DECIMAL(10,2) NOT NULL,
    "Quantity" INT NOT NULL,
    "Subtotal" DECIMAL(10,2) NOT NULL,
    
    CONSTRAINT "fk_orderitems_order" FOREIGN KEY ("OrderId") 
        REFERENCES "Orders"("Id") ON DELETE CASCADE,
    CONSTRAINT "fk_orderitems_product" FOREIGN KEY ("ProductId") 
        REFERENCES "Products"("Id") ON DELETE RESTRICT
);

CREATE INDEX "idx_orderitems_orderid" ON "OrderItems"("OrderId");
CREATE INDEX "idx_orderitems_productid" ON "OrderItems"("ProductId");
```

**说明**: 冗余存储商品信息，避免商品修改后影响历史订单

#### 5. ShippingRates（运费配置表）

```sql
CREATE TABLE "ShippingRates" (
    "Id" SERIAL PRIMARY KEY,
    "Province" VARCHAR(50) NOT NULL UNIQUE,
    "Rate" DECIMAL(10,2) NOT NULL,
    "CreatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "UpdatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**说明**: 按省份配置不同运费单价，支持动态调整

---

## API接口设计

### 统一响应格式

```json
{
  "success": true,
  "message": "操作成功",
  "data": {},
  "timestamp": "2025-10-17T10:30:00Z"
}
```

### 错误响应格式

```json
{
  "success": false,
  "message": "错误信息",
  "errors": ["详细错误1", "详细错误2"],
  "timestamp": "2025-10-17T10:30:00Z"
}
```

### 接口列表

#### 1. 商品管理

```http
# 获取所有商品
GET /api/products
Response: ApiResponse<List<ProductDto>>

# 获取单个商品
GET /api/products/{id}
Response: ApiResponse<ProductDto>

# 创建商品
POST /api/products
Body: CreateProductDto
Response: ApiResponse<ProductDto>

# 更新商品
PUT /api/products/{id}
Body: UpdateProductDto
Response: ApiResponse<ProductDto>

# 删除商品
DELETE /api/products/{id}
Response: ApiResponse<bool>
```

#### 2. 地址管理

```http
# 获取所有地址
GET /api/addresses
Response: ApiResponse<List<AddressDto>>

# 获取单个地址
GET /api/addresses/{id}
Response: ApiResponse<AddressDto>

# 创建地址
POST /api/addresses
Body: CreateAddressDto
Response: ApiResponse<AddressDto>

# 更新地址
PUT /api/addresses/{id}
Body: UpdateAddressDto
Response: ApiResponse<AddressDto>

# 删除地址
DELETE /api/addresses/{id}
Response: ApiResponse<bool>

# 设置默认地址
PUT /api/addresses/{id}/set-default
Response: ApiResponse<bool>

# 智能识别地址
POST /api/addresses/parse
Body: { "text": "张三 13800138000 广东省深圳市..." }
Response: ApiResponse<ParsedAddressDto>
```

#### 3. 订单管理

```http
# 获取订单列表（分页）
GET /api/orders?page=1&pageSize=10&status=待发货
Response: ApiResponse<PagedResult<OrderDto>>

# 获取订单详情
GET /api/orders/{id}
Response: ApiResponse<OrderDetailDto>

# 创建订单
POST /api/orders
Body: CreateOrderDto
Response: ApiResponse<OrderDto>

# 更新订单状态
PUT /api/orders/{id}/status
Body: { "status": "已发货" }
Response: ApiResponse<bool>

# 删除订单
DELETE /api/orders/{id}
Response: ApiResponse<bool>

# 批量删除订单
DELETE /api/orders/batch
Body: { "orderIds": [1, 2, 3] }
Response: ApiResponse<bool>
```

#### 4. 运费管理

```http
# 计算运费
POST /api/shipping/calculate
Body: { "province": "广东省", "weight": 20.0 }
Response: ApiResponse<ShippingCalculationDto>

# 获取运费配置
GET /api/shipping/rates
Response: ApiResponse<List<ShippingRateDto>>

# 更新运费配置
PUT /api/shipping/rates/{province}
Body: { "rate": 1.8 }
Response: ApiResponse<ShippingRateDto>
```

---

## 项目结构

```
LLXRice.Api/
├── LLXRice.Api.sln                   # 解决方案文件
├── .cursorrules                       # Cursor 开发规则
├── .dockerignore
├── Dockerfile
├── docker-compose.yml
├── .github/
│   └── workflows/
│       └── ci-cd.yml                  # CI/CD 配置
├── src/
│   └── LLXRice.Api/                  # 主项目
│       ├── Program.cs                 # 应用入口（Minimal API）
│       ├── appsettings.json
│       ├── appsettings.Development.json
│       ├── appsettings.Production.json
│       ├── LLXRice.Api.csproj
│       ├── Models/
│       │   ├── Entities/              # 实体模型
│       │   │   ├── Product.cs
│       │   │   ├── Address.cs
│       │   │   ├── Order.cs
│       │   │   ├── OrderItem.cs
│       │   │   └── ShippingRate.cs
│       │   └── DTOs/                  # 数据传输对象
│       │       ├── ProductDtos.cs
│       │       ├── AddressDtos.cs
│       │       ├── OrderDtos.cs
│       │       ├── ShippingDtos.cs
│       │       └── ApiResponse.cs
│       ├── Data/
│       │   ├── AppDbContext.cs        # EF Core 上下文
│       │   └── Migrations/            # 数据库迁移
│       ├── Services/
│       │   ├── IProductService.cs
│       │   ├── ProductService.cs
│       │   ├── IAddressService.cs
│       │   ├── AddressService.cs
│       │   ├── IOrderService.cs
│       │   ├── OrderService.cs
│       │   ├── IShippingService.cs
│       │   ├── ShippingService.cs
│       │   └── ICacheService.cs
│       │       └── RedisCacheService.cs
│       ├── Repositories/
│       │   ├── IRepository.cs         # 通用仓储接口
│       │   ├── Repository.cs          # 通用仓储实现
│       │   ├── IProductRepository.cs
│       │   ├── ProductRepository.cs
│       │   ├── IAddressRepository.cs
│       │   ├── AddressRepository.cs
│       │   ├── IOrderRepository.cs
│       │   └── OrderRepository.cs
│       ├── Endpoints/                 # Minimal API 端点
│       │   ├── ProductEndpoints.cs
│       │   ├── AddressEndpoints.cs
│       │   ├── OrderEndpoints.cs
│       │   └── ShippingEndpoints.cs
│       ├── Utils/
│       │   ├── AddressParser.cs       # 地址解析工具
│       │   └── OrderNumberGenerator.cs
│       ├── Middleware/
│       │   ├── ExceptionMiddleware.cs # 全局异常处理
│       │   └── LoggingMiddleware.cs   # 请求日志
│       └── Extensions/
│           ├── ServiceCollectionExtensions.cs
│           └── EndpointRouteBuilderExtensions.cs
├── scripts/
│   ├── init-db.sql                    # 数据库初始化脚本
│   ├── deploy-docker.sh               # Docker 部署脚本
│   └── deploy-service.sh              # Systemd 服务部署脚本
├── docs/
│   ├── API.md                         # API 文档
│   ├── DEPLOYMENT.md                  # 部署文档
│   └── DEVELOPMENT.md                 # 开发指南
└── README.md
```

---

## 核心代码实现

### 1. Program.cs（Minimal API 入口）

```csharp
using LLXRice.Api.Data;
using LLXRice.Api.Extensions;
using LLXRice.Api.Middleware;
using Microsoft.EntityFrameworkCore;
using Serilog;
using StackExchange.Redis;

var builder = WebApplication.CreateBuilder(args);

// ========== 配置 Serilog ==========
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console()
    .WriteTo.File("logs/log-.txt", rollingInterval: RollingInterval.Day)
    .CreateLogger();

builder.Host.UseSerilog();

// ========== 配置服务 ==========

// 添加 CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

// 配置 PostgreSQL
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

// 配置 Redis
var redisConnection = builder.Configuration.GetConnectionString("Redis");
builder.Services.AddSingleton<IConnectionMultiplexer>(
    ConnectionMultiplexer.Connect(redisConnection));

// 注册服务和仓储
builder.Services.RegisterServices();
builder.Services.RegisterRepositories();

// 添加 Swagger
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new()
    {
        Title = "林龍香大米商城 API",
        Version = "v1",
        Description = "基于 .NET 8 Minimal API 的后端服务"
    });
});

// 添加健康检查
builder.Services.AddHealthChecks()
    .AddNpgSql(builder.Configuration.GetConnectionString("DefaultConnection"))
    .AddRedis(redisConnection);

var app = builder.Build();

// ========== 配置中间件管道 ==========

// Swagger（开发和生产都启用，方便测试）
app.UseSwagger();
app.UseSwaggerUI(c =>
{
    c.SwaggerEndpoint("/swagger/v1/swagger.json", "LLXRice API v1");
    c.RoutePrefix = string.Empty; // Swagger UI 作为根路径
});

// 全局异常处理
app.UseMiddleware<ExceptionMiddleware>();

// 请求日志
app.UseMiddleware<LoggingMiddleware>();

// CORS
app.UseCors("AllowAll");

// HTTPS 重定向（生产环境）
if (!app.Environment.IsDevelopment())
{
    app.UseHttpsRedirection();
}

// 健康检查
app.MapHealthChecks("/health");

// ========== 注册 API 端点 ==========
app.MapProductEndpoints();
app.MapAddressEndpoints();
app.MapOrderEndpoints();
app.MapShippingEndpoints();

// ========== 数据库迁移（生产环境建议手动执行） ==========
if (app.Environment.IsDevelopment())
{
    using (var scope = app.Services.CreateScope())
    {
        var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        await dbContext.Database.MigrateAsync();
        Log.Information("数据库迁移完成");
    }
}

// ========== 启动应用 ==========
Log.Information("应用启动中...");
app.Run();
Log.Information("应用已关闭");
```

### 2. ApiResponse（统一响应模型）

```csharp
namespace LLXRice.Api.Models.DTOs;

public class ApiResponse<T>
{
    public bool Success { get; set; } = true;
    public string Message { get; set; } = "操作成功";
    public T? Data { get; set; }
    public List<string>? Errors { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    public static ApiResponse<T> SuccessResponse(T data, string message = "操作成功")
    {
        return new ApiResponse<T>
        {
            Success = true,
            Message = message,
            Data = data
        };
    }

    public static ApiResponse<T> ErrorResponse(string message, List<string>? errors = null)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Message = message,
            Errors = errors
        };
    }
}
```

### 3. ProductEndpoints（商品端点）

```csharp
using LLXRice.Api.Models.DTOs;
using LLXRice.Api.Services;
using Microsoft.AspNetCore.Mvc;

namespace LLXRice.Api.Endpoints;

public static class ProductEndpoints
{
    public static void MapProductEndpoints(this IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("/api/products")
            .WithTags("Products")
            .WithOpenApi();

        // GET /api/products
        group.MapGet("/", async (IProductService service) =>
        {
            var products = await service.GetAllAsync();
            return Results.Ok(ApiResponse<List<ProductDto>>.SuccessResponse(products));
        })
        .WithName("GetProducts")
        .Produces<ApiResponse<List<ProductDto>>>();

        // GET /api/products/{id}
        group.MapGet("/{id}", async (int id, IProductService service) =>
        {
            var product = await service.GetByIdAsync(id);
            if (product == null)
                return Results.NotFound(ApiResponse<ProductDto>.ErrorResponse("商品不存在"));

            return Results.Ok(ApiResponse<ProductDto>.SuccessResponse(product));
        })
        .WithName("GetProduct")
        .Produces<ApiResponse<ProductDto>>()
        .Produces(404);

        // POST /api/products
        group.MapPost("/", async ([FromBody] CreateProductDto dto, IProductService service) =>
        {
            var product = await service.CreateAsync(dto);
            return Results.Created($"/api/products/{product.Id}",
                ApiResponse<ProductDto>.SuccessResponse(product, "创建成功"));
        })
        .WithName("CreateProduct")
        .Produces<ApiResponse<ProductDto>>(201);

        // PUT /api/products/{id}
        group.MapPut("/{id}", async (int id, [FromBody] UpdateProductDto dto, IProductService service) =>
        {
            var product = await service.UpdateAsync(id, dto);
            if (product == null)
                return Results.NotFound(ApiResponse<ProductDto>.ErrorResponse("商品不存在"));

            return Results.Ok(ApiResponse<ProductDto>.SuccessResponse(product, "更新成功"));
        })
        .WithName("UpdateProduct")
        .Produces<ApiResponse<ProductDto>>()
        .Produces(404);

        // DELETE /api/products/{id}
        group.MapDelete("/{id}", async (int id, IProductService service) =>
        {
            var success = await service.DeleteAsync(id);
            if (!success)
                return Results.NotFound(ApiResponse<bool>.ErrorResponse("商品不存在"));

            return Results.Ok(ApiResponse<bool>.SuccessResponse(true, "删除成功"));
        })
        .WithName("DeleteProduct")
        .Produces<ApiResponse<bool>>()
        .Produces(404);
    }
}
```

### 4. AddressParser（地址智能识别）

```csharp
using System.Text.RegularExpressions;

namespace LLXRice.Api.Utils;

public class AddressParser
{
    // 省份列表
    private static readonly string[] Provinces = new[]
    {
        "北京市", "天津市", "上海市", "重庆市",
        "河北省", "山西省", "辽宁省", "吉林省", "黑龙江省",
        "江苏省", "浙江省", "安徽省", "福建省", "江西省", "山东省",
        "河南省", "湖北省", "湖南省", "广东省", "海南省",
        "四川省", "贵州省", "云南省", "陕西省", "甘肃省", "青海省",
        "内蒙古自治区", "广西壮族自治区", "西藏自治区", "宁夏回族自治区", "新疆维吾尔自治区",
        "香港特别行政区", "澳门特别行政区", "台湾省"
    };

    public static ParsedAddress Parse(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            throw new ArgumentException("地址文本不能为空");

        var result = new ParsedAddress();
        
        // 清理文本：去除多余空格、换行等
        var cleanText = Regex.Replace(text, @"\s+", " ").Trim();
        
        // 1. 提取姓名（2-4个汉字，在开头或"收货人"之后）
        var nameMatch = Regex.Match(cleanText, @"(?:收货人[:：\s]*)?(?<name>[\u4e00-\u9fa5]{2,4})(?:先生|女士)?");
        if (nameMatch.Success)
        {
            result.Name = nameMatch.Groups["name"].Value;
            cleanText = cleanText.Replace(nameMatch.Value, "");
        }

        // 2. 提取电话（11位手机号或带区号的固定电话）
        var phoneMatch = Regex.Match(cleanText, @"(?:电话|手机|联系方式)?[:：\s]*(?<phone>1[3-9]\d{9}|\d{3,4}-?\d{7,8})");
        if (phoneMatch.Success)
        {
            result.Phone = phoneMatch.Groups["phone"].Value.Replace("-", "");
            cleanText = cleanText.Replace(phoneMatch.Value, "");
        }

        // 3. 提取省份
        foreach (var province in Provinces)
        {
            if (cleanText.Contains(province))
            {
                result.Province = province;
                cleanText = cleanText.Replace(province, "");
                break;
            }
            // 尝试去掉"省"、"市"匹配
            var shortProvince = province.Replace("省", "").Replace("市", "").Replace("自治区", "").Replace("特别行政区", "");
            if (cleanText.Contains(shortProvince))
            {
                result.Province = province;
                cleanText = cleanText.Replace(shortProvince, "");
                break;
            }
        }

        // 4. 提取城市
        var cityMatch = Regex.Match(cleanText, @"(?<city>[\u4e00-\u9fa5]{2,10}?(?:市|地区|州|盟))");
        if (cityMatch.Success)
        {
            result.City = cityMatch.Value;
            cleanText = cleanText.Replace(cityMatch.Value, "");
        }

        // 5. 提取区县
        var districtMatch = Regex.Match(cleanText, @"(?<district>[\u4e00-\u9fa5]{2,10}?(?:区|县|市|旗))");
        if (districtMatch.Success)
        {
            result.District = districtMatch.Value;
            cleanText = cleanText.Replace(districtMatch.Value, "");
        }

        // 6. 剩余部分作为详细地址
        result.Detail = cleanText.Trim()
            .Replace("地址", "")
            .Replace(":", "")
            .Replace("：", "")
            .Trim();

        return result;
    }
}

public class ParsedAddress
{
    public string Name { get; set; } = string.Empty;
    public string Phone { get; set; } = string.Empty;
    public string Province { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
    public string District { get; set; } = string.Empty;
    public string Detail { get; set; } = string.Empty;
}
```

---

## Redis缓存策略

### 缓存设计原则

1. **热点数据缓存**: 商品列表、运费配置等高频读取数据
2. **缓存失效策略**: 更新数据时主动失效缓存
3. **缓存穿透保护**: 空值缓存，防止恶意查询
4. **缓存雪崩保护**: 随机过期时间，避免集中失效

### 缓存键命名规范

```
llxrice:products:all              # 所有商品列表
llxrice:products:{id}             # 单个商品
llxrice:shipping:rates            # 运费配置
llxrice:orders:{id}               # 订单详情
```

### RedisCacheService 实现

```csharp
using StackExchange.Redis;
using System.Text.Json;

namespace LLXRice.Api.Services;

public interface ICacheService
{
    Task<T?> GetAsync<T>(string key);
    Task SetAsync<T>(string key, T value, TimeSpan? expiry = null);
    Task RemoveAsync(string key);
    Task RemoveByPatternAsync(string pattern);
}

public class RedisCacheService : ICacheService
{
    private readonly IDatabase _db;
    private readonly IServer _server;

    public RedisCacheService(IConnectionMultiplexer redis)
    {
        _db = redis.GetDatabase();
        _server = redis.GetServer(redis.GetEndPoints().First());
    }

    public async Task<T?> GetAsync<T>(string key)
    {
        var value = await _db.StringGetAsync(key);
        if (value.IsNullOrEmpty)
            return default;

        return JsonSerializer.Deserialize<T>(value!);
    }

    public async Task SetAsync<T>(string key, T value, TimeSpan? expiry = null)
    {
        var json = JsonSerializer.Serialize(value);
        await _db.StringSetAsync(key, json, expiry ?? TimeSpan.FromHours(1));
    }

    public async Task RemoveAsync(string key)
    {
        await _db.KeyDeleteAsync(key);
    }

    public async Task RemoveByPatternAsync(string pattern)
    {
        var keys = _server.Keys(pattern: pattern).ToArray();
        if (keys.Any())
            await _db.KeyDeleteAsync(keys);
    }
}
```

### 使用示例（ProductService）

```csharp
public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    private readonly ICacheService _cache;
    private const string CacheKeyAll = "llxrice:products:all";
    private const string CacheKeyPrefix = "llxrice:products:";

    public async Task<List<ProductDto>> GetAllAsync()
    {
        // 尝试从缓存获取
        var cached = await _cache.GetAsync<List<ProductDto>>(CacheKeyAll);
        if (cached != null)
            return cached;

        // 缓存未命中，从数据库获取
        var products = await _repository.GetAllAsync();
        var dtos = products.Select(MapToDto).ToList();

        // 写入缓存，随机过期时间（50-70分钟）
        var expiry = TimeSpan.FromMinutes(50 + new Random().Next(20));
        await _cache.SetAsync(CacheKeyAll, dtos, expiry);

        return dtos;
    }

    public async Task<ProductDto> CreateAsync(CreateProductDto dto)
    {
        var product = await _repository.AddAsync(MapToEntity(dto));
        
        // 清除缓存
        await _cache.RemoveAsync(CacheKeyAll);
        
        return MapToDto(product);
    }
}
```

---

## 部署方案

### 方案一：Docker Compose 部署（推荐）

#### 1. Dockerfile

```dockerfile
# Dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
EXPOSE 8081

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["src/LLXRice.Api/LLXRice.Api.csproj", "LLXRice.Api/"]
RUN dotnet restore "LLXRice.Api/LLXRice.Api.csproj"
COPY src/ .
WORKDIR "/src/LLXRice.Api"
RUN dotnet build "LLXRice.Api.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "LLXRice.Api.csproj" -c Release -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .

# 创建日志目录
RUN mkdir -p /app/logs

# 设置环境变量
ENV ASPNETCORE_URLS=http://+:8080
ENV ASPNETCORE_ENVIRONMENT=Production

ENTRYPOINT ["dotnet", "LLXRice.Api.dll"]
```

#### 2. docker-compose.yml

```yaml
version: '3.8'

services:
  # PostgreSQL 数据库
  postgres:
    image: postgres:16-alpine
    container_name: llxrice_db
    restart: unless-stopped
    environment:
      POSTGRES_DB: llxrice
      POSTGRES_USER: llxrice_user
      POSTGRES_PASSWORD: ${DB_PASSWORD:-your_strong_password}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    networks:
      - llxrice_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U llxrice_user -d llxrice"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis 缓存
  redis:
    image: redis:7.2-alpine
    container_name: llxrice_redis
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-your_redis_password}
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - llxrice_network
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # .NET API 服务
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: llxrice_api
    restart: unless-stopped
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Host=postgres;Port=5432;Database=llxrice;Username=llxrice_user;Password=${DB_PASSWORD:-your_strong_password}
      - ConnectionStrings__Redis=redis:6379,password=${REDIS_PASSWORD:-your_redis_password}
    expose:
      - "8080"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - llxrice_network
    volumes:
      - ./logs:/app/logs
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    container_name: llxrice_nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - ./nginx/logs:/var/log/nginx
      - ./static:/usr/share/nginx/html:ro
    depends_on:
      - api
    networks:
      - llxrice_network
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local

networks:
  llxrice_network:
    driver: bridge
```

#### 3. .env 文件

```bash
# .env
DB_PASSWORD=your_strong_db_password_here
REDIS_PASSWORD=your_strong_redis_password_here
```

#### 4. Nginx 配置文件

**nginx/nginx.conf** (主配置文件)

```nginx
user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
    use epoll;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # 日志格式
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for" '
                      'rt=$request_time uct="$upstream_connect_time" '
                      'uht="$upstream_header_time" urt="$upstream_response_time"';

    access_log  /var/log/nginx/access.log  main;

    # 性能优化
    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout  65;
    types_hash_max_size 2048;
    client_max_body_size 20M;

    # Gzip 压缩
    gzip  on;
    gzip_vary on;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss 
               application/rss+xml font/truetype font/opentype 
               application/vnd.ms-fontobject image/svg+xml;
    gzip_disable "msie6";

    # 限流配置
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/s;
    limit_req_zone $binary_remote_addr zone=login_limit:10m rate=5r/s;
    
    # 连接限制
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;

    # 包含站点配置
    include /etc/nginx/conf.d/*.conf;
}
```

**nginx/conf.d/llxrice.conf** (站点配置)

```nginx
# API 上游服务器
upstream llxrice_api {
    # 负载均衡策略：least_conn (最少连接)
    least_conn;
    
    # 后端 API 服务器列表
    server api:8080 max_fails=3 fail_timeout=30s;
    # 如有多个实例，添加更多服务器
    # server api2:8080 max_fails=3 fail_timeout=30s;
    # server api3:8080 max_fails=3 fail_timeout=30s;
    
    # 保持连接
    keepalive 32;
}

# HTTP 服务器 (重定向到 HTTPS)
server {
    listen 80;
    server_name api.llxrice.com;  # 替换为实际域名
    
    # Let's Encrypt 证书验证
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
    
    # 重定向到 HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

# HTTPS 服务器
server {
    listen 443 ssl http2;
    server_name api.llxrice.com;  # 替换为实际域名
    
    # SSL 证书配置
    ssl_certificate /etc/nginx/ssl/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/privkey.pem;
    
    # SSL 安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # HSTS (可选，生产环境推荐)
    # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # 安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # 访问日志
    access_log /var/log/nginx/llxrice_access.log main;
    error_log /var/log/nginx/llxrice_error.log warn;
    
    # 连接限制：每个 IP 最多 20 个连接
    limit_conn conn_limit 20;
    
    # API 请求
    location /api/ {
        # 请求限流：每秒 100 个请求，突发 200
        limit_req zone=api_limit burst=200 nodelay;
        
        # 代理到后端 API
        proxy_pass http://llxrice_api/;
        
        # 代理头设置
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # 缓冲设置
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
        proxy_busy_buffers_size 8k;
        
        # WebSocket 支持 (如需要)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
    
    # 健康检查端点 (不限流)
    location /health {
        proxy_pass http://llxrice_api/health;
        access_log off;
    }
    
    # Swagger 文档 (开发/测试环境)
    location /swagger {
        proxy_pass http://llxrice_api/swagger;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # 静态资源
    location /static/ {
        alias /usr/share/nginx/html/;
        expires 7d;
        add_header Cache-Control "public, immutable";
    }
    
    # 错误页面
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/share/nginx/html;
    }
}
```

**nginx/conf.d/http_upgrade.conf** (HTTP 到 HTTPS 升级，可选)

```nginx
# 对所有 HTTP 请求返回 301 重定向到 HTTPS
server {
    listen 80 default_server;
    server_name _;
    return 301 https://$host$request_uri;
}
```

#### 5. SSL 证书配置

**使用 Let's Encrypt 免费证书**

```bash
# 安装 Certbot
sudo apt install certbot python3-certbot-nginx

# 获取证书
sudo certbot --nginx -d api.llxrice.com

# 自动续期
sudo certbot renew --dry-run
```

**使用自签名证书（开发环境）**

```bash
# 创建 SSL 目录
mkdir -p nginx/ssl

# 生成自签名证书
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout nginx/ssl/privkey.pem \
  -out nginx/ssl/fullchain.pem \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=LLXRice/CN=api.llxrice.com"
```

#### 6. 目录结构

```
project/
├── docker-compose.yml
├── Dockerfile
├── .env
├── nginx/
│   ├── nginx.conf           # 主配置文件
│   ├── conf.d/
│   │   ├── llxrice.conf     # 站点配置
│   │   └── http_upgrade.conf  # HTTP升级配置
│   ├── ssl/
│   │   ├── fullchain.pem    # SSL 证书
│   │   └── privkey.pem      # 私钥
│   └── logs/                # Nginx 日志
├── static/                  # 静态资源
└── logs/                    # API 日志
```

#### 7. 部署命令

```bash
# 1. 克隆代码
git clone <repository-url>
cd LLXRice.Api

# 2. 创建必要的目录
mkdir -p nginx/conf.d nginx/ssl nginx/logs static logs

# 3. 创建 nginx 配置文件
# 复制上面提供的配置文件内容到相应位置
cat > nginx/nginx.conf << 'EOF'
# 粘贴 nginx.conf 内容
EOF

cat > nginx/conf.d/llxrice.conf << 'EOF'
# 粘贴 llxrice.conf 内容
EOF

# 4. 生成 SSL 证书（开发环境使用自签名）
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout nginx/ssl/privkey.pem \
  -out nginx/ssl/fullchain.pem \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=LLXRice/CN=api.llxrice.com"

# 5. 创建 .env 文件并设置密码
cat > .env << EOF
DB_PASSWORD=your_strong_password
REDIS_PASSWORD=your_redis_password
EOF

# 6. 启动所有服务（包括 Nginx）
docker-compose up -d

# 7. 查看服务状态
docker-compose ps

# 8. 查看日志
docker-compose logs -f nginx    # Nginx 日志
docker-compose logs -f api      # API 日志

# 9. 测试服务
curl http://localhost/health    # 通过 Nginx 访问
curl http://localhost:8080/health  # 直接访问 API (仅用于测试)

# 10. 查看 Nginx 配置是否正确
docker exec llxrice_nginx nginx -t

# 11. 重新加载 Nginx 配置（无需重启）
docker exec llxrice_nginx nginx -s reload

# 12. 查看 Nginx 访问日志
tail -f nginx/logs/llxrice_access.log

# 13. 停止服务
docker-compose down

# 14. 停止并删除数据卷（危险操作）
docker-compose down -v
```

#### 8. Nginx 性能优化建议

**1. Worker 进程数优化**
```nginx
# 设置为 CPU 核心数
worker_processes auto;

# 每个 worker 的最大连接数
events {
    worker_connections 4096;
}
```

**2. 启用缓存**
```nginx
# 在 http 块中添加
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api_cache:10m inactive=60m;
proxy_cache_key "$scheme$request_method$host$request_uri";

# 在 location 块中使用
location /api/ {
    proxy_cache api_cache;
    proxy_cache_valid 200 5m;
    proxy_cache_valid 404 1m;
    add_header X-Cache-Status $upstream_cache_status;
}
```

**3. 连接保持优化**
```nginx
keepalive_timeout 65;
keepalive_requests 100;

upstream llxrice_api {
    keepalive 32;
    keepalive_timeout 60s;
}
```

#### 9. Nginx 监控和维护

**查看 Nginx 状态**
```bash
# 查看 Nginx 进程
ps aux | grep nginx

# 查看端口占用
netstat -tlnp | grep nginx

# 查看错误日志
tail -f nginx/logs/llxrice_error.log
```

**日志分析**
```bash
# 统计访问最多的 IP
awk '{print $1}' nginx/logs/llxrice_access.log | sort | uniq -c | sort -rn | head -10

# 统计访问最多的 URL
awk '{print $7}' nginx/logs/llxrice_access.log | sort | uniq -c | sort -rn | head -10

# 统计响应时间
awk '{print $NF}' nginx/logs/llxrice_access.log | sort -n | tail -100
```

**日志轮转**
```bash
# 创建 logrotate 配置
cat > /etc/logrotate.d/nginx << EOF
/path/to/nginx/logs/*.log {
    daily
    rotate 30
    compress
    delaycompress
    notifempty
    create 0640 nginx nginx
    sharedscripts
    postrotate
        docker exec llxrice_nginx nginx -s reload > /dev/null 2>&1
    endscript
}
EOF
```

### 方案二：Systemd 服务部署

#### 1. 环境准备

```bash
# 更新系统
sudo apt update && sudo apt upgrade -y

# 安装 .NET 8 Runtime
wget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb
rm packages-microsoft-prod.deb
sudo apt update
sudo apt install -y aspnetcore-runtime-8.0

# 安装 PostgreSQL 16
sudo apt install -y postgresql-16 postgresql-contrib-16

# 安装 Redis
sudo apt install -y redis-server

# 配置 Redis 密码
sudo nano /etc/redis/redis.conf
# 找到 # requirepass foobared
# 修改为 requirepass your_redis_password
sudo systemctl restart redis-server

# 安装 Nginx
sudo apt install -y nginx

# 启动 Nginx
sudo systemctl start nginx
sudo systemctl enable nginx
```

#### 2. 部署应用

```bash
# 发布应用
cd src/LLXRice.Api
dotnet publish -c Release -o /var/www/llxrice-api

# 创建日志目录
sudo mkdir -p /var/www/llxrice-api/logs
sudo chown -R www-data:www-data /var/www/llxrice-api

# 创建配置文件
sudo nano /var/www/llxrice-api/appsettings.Production.json
```

**appsettings.Production.json**:

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=llxrice;Username=llxrice_user;Password=your_db_password",
    "Redis": "localhost:6379,password=your_redis_password"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

#### 3. 创建 Systemd 服务

```bash
sudo nano /etc/systemd/system/llxrice-api.service
```

**llxrice-api.service**:

```ini
[Unit]
Description=LLXRice API Service
After=network.target postgresql.service redis.service

[Service]
Type=notify
User=www-data
WorkingDirectory=/var/www/llxrice-api
ExecStart=/usr/bin/dotnet /var/www/llxrice-api/LLXRice.Api.dll
Restart=always
RestartSec=10
KillSignal=SIGINT
SyslogIdentifier=llxrice-api
Environment=ASPNETCORE_ENVIRONMENT=Production
Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false

[Install]
WantedBy=multi-user.target
```

#### 4. 启动服务

```bash
# 重新加载 systemd
sudo systemctl daemon-reload

# 启动服务
sudo systemctl start llxrice-api

# 设置开机自启
sudo systemctl enable llxrice-api

# 查看状态
sudo systemctl status llxrice-api

# 查看日志
sudo journalctl -u llxrice-api -f
```

#### 5. 配置 Nginx 反向代理

**创建 Nginx 配置文件**:

```bash
sudo nano /etc/nginx/sites-available/llxrice-api
```

**完整的 Nginx 配置**:

```nginx
# HTTP 服务器 (重定向到 HTTPS)
server {
    listen 80;
    server_name api.llxrice.com;  # 替换为您的域名
    
    # Let's Encrypt 证书验证
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
    
    # 重定向到 HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

# HTTPS 服务器
server {
    listen 443 ssl http2;
    server_name api.llxrice.com;  # 替换为您的域名
    
    # SSL 证书配置
    ssl_certificate /etc/letsencrypt/live/api.llxrice.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.llxrice.com/privkey.pem;
    
    # SSL 安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # 安全头
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # 日志
    access_log /var/log/nginx/llxrice_access.log;
    error_log /var/log/nginx/llxrice_error.log warn;
    
    # 限流配置
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/s;
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;
    
    # 连接限制
    limit_conn conn_limit 20;
    
    # API 请求
    location /api/ {
        # 请求限流
        limit_req zone=api_limit burst=200 nodelay;
        
        # 代理到后端
        proxy_pass http://localhost:8080/;
        proxy_http_version 1.1;
        
        # 代理头设置
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # 缓冲设置
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
    }
    
    # 健康检查端点 (不限流)
    location /health {
        proxy_pass http://localhost:8080/health;
        access_log off;
    }
    
    # Swagger 文档
    location /swagger {
        proxy_pass http://localhost:8080/swagger;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # 静态资源
    location /static/ {
        alias /var/www/llxrice-api/wwwroot/;
        expires 7d;
        add_header Cache-Control "public, immutable";
    }
}
```

**启用站点并配置 SSL**:

```bash
# 创建符号链接启用站点
sudo ln -s /etc/nginx/sites-available/llxrice-api /etc/nginx/sites-enabled/

# 检查 Nginx 配置
sudo nginx -t

# 暂时重启 Nginx (使用 HTTP 配置)
sudo systemctl restart nginx

# 安装 Certbot 并获取 SSL 证书
sudo apt install -y certbot python3-certbot-nginx

# 获取 Let's Encrypt 证书
sudo certbot --nginx -d api.llxrice.com

# 自动续期证书（设置定时任务）
sudo certbot renew --dry-run

# 添加自动续期的 cron 任务
(crontab -l 2>/dev/null; echo "0 0 1 * * /usr/bin/certbot renew --quiet") | crontab -

# 重启 Nginx 使 HTTPS 配置生效
sudo systemctl restart nginx

# 查看 Nginx 状态
sudo systemctl status nginx
```

**Nginx 优化配置** (可选):

编辑 `/etc/nginx/nginx.conf`:

```nginx
user www-data;
worker_processes auto;
pid /run/nginx.pid;

events {
    worker_connections 2048;
    use epoll;
    multi_accept on;
}

http {
    # 基础设置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 20M;
    
    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss;
    
    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time';
    
    # 包含站点配置
    include /etc/nginx/mime.types;
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
```

### 部署检查清单

#### 数据库和缓存
- [ ] PostgreSQL 服务运行正常
- [ ] Redis 服务运行正常
- [ ] 数据库连接正常
- [ ] Redis 连接正常
- [ ] 数据库已初始化（表和初始数据）
- [ ] 数据库备份策略已设置

#### API 服务
- [ ] .NET API 服务启动正常
- [ ] Swagger 文档可访问
- [ ] 健康检查端点正常 (`/health`)
- [ ] API 日志文件正常写入
- [ ] CORS 配置正确

#### Nginx 反向代理
- [ ] Nginx 服务运行正常
- [ ] Nginx 配置语法正确 (`nginx -t`)
- [ ] HTTP 到 HTTPS 重定向正常
- [ ] SSL 证书已配置且有效
- [ ] SSL 证书自动续期已设置
- [ ] 代理到后端 API 正常
- [ ] 请求限流配置生效
- [ ] Gzip 压缩正常工作
- [ ] Nginx 访问日志正常写入
- [ ] 静态资源服务正常

#### 网络和安全
- [ ] 防火墙端口已开放（80, 443）
- [ ] 内部端口已限制访问（8080, 5432, 6379）
- [ ] 安全头配置正确
- [ ] HTTPS 强制跳转正常
- [ ] 域名 DNS 解析正确

#### 监控和运维
- [ ] 日志轮转配置正确
- [ ] 磁盘空间充足
- [ ] 服务开机自启已配置
- [ ] 监控告警已设置（可选）

#### 功能测试
- [ ] API 接口调用正常
- [ ] 数据读写正常
- [ ] 缓存命中正常
- [ ] 并发测试通过
- [ ] 性能测试达标

---

## 开发规范

### 命名规范

1. **类名**: PascalCase，如 `ProductService`
2. **接口名**: I + PascalCase，如 `IProductService`
3. **方法名**: PascalCase，如 `GetAllAsync`
4. **参数/变量**: camelCase，如 `productId`
5. **常量**: PascalCase，如 `CacheKeyAll`
6. **私有字段**: _camelCase，如 `_repository`

### 异步编程

- 所有 I/O 操作必须使用异步方法
- 异步方法名必须以 `Async` 结尾
- 使用 `async/await`，不要使用 `.Result` 或 `.Wait()`

```csharp
// ✅ 正确
public async Task<List<Product>> GetAllAsync()
{
    return await _repository.GetAllAsync();
}

// ❌ 错误
public List<Product> GetAll()
{
    return _repository.GetAllAsync().Result;
}
```

### 错误处理

- 使用全局异常中间件处理异常
- 业务异常抛出自定义异常
- 记录详细的错误日志

```csharp
public async Task<Product> GetByIdAsync(int id)
{
    var product = await _repository.GetByIdAsync(id);
    if (product == null)
        throw new NotFoundException($"商品 {id} 不存在");
    
    return product;
}
```

### 日志记录

- 使用 Serilog 结构化日志
- 关键操作记录日志
- 包含上下文信息

```csharp
_logger.LogInformation("创建商品: {ProductName}, 价格: {Price}", dto.Name, dto.Price);
_logger.LogError(ex, "获取商品 {ProductId} 失败", id);
```

---

## 小程序对接说明

### 1. API 基础配置

在小程序中配置服务器域名（微信公众平台 -> 开发 -> 开发设置 -> 服务器域名）:

```
request合法域名: https://api.llxrice.com
```

### 2. HTTP 客户端封装

创建 `utils/httpClient.js`:

```javascript
const BASE_URL = 'https://api.llxrice.com/api'

class HttpClient {
  static async request(url, method = 'GET', data = null) {
    return new Promise((resolve, reject) => {
      wx.showLoading({ title: '加载中...', mask: true })
      
      wx.request({
        url: `${BASE_URL}${url}`,
        method,
        data,
        header: {
          'Content-Type': 'application/json'
        },
        success: (res) => {
          wx.hideLoading()
          if (res.statusCode === 200 && res.data.success) {
            resolve(res.data.data)
          } else {
            wx.showToast({
              title: res.data.message || '请求失败',
              icon: 'none'
            })
            reject(res.data)
          }
        },
        fail: (err) => {
          wx.hideLoading()
          wx.showToast({ title: '网络请求失败', icon: 'none' })
          reject(err)
        }
      })
    })
  }

  static get(url) {
    return this.request(url, 'GET')
  }

  static post(url, data) {
    return this.request(url, 'POST', data)
  }

  static put(url, data) {
    return this.request(url, 'PUT', data)
  }

  static delete(url) {
    return this.request(url, 'DELETE')
  }
}

module.exports = HttpClient
```

### 3. API 服务封装

创建 `utils/apiService.js`:

```javascript
const HttpClient = require('./httpClient.js')

class ApiService {
  // ========== 商品 ==========
  static getProducts() {
    return HttpClient.get('/products')
  }

  static createProduct(data) {
    return HttpClient.post('/products', data)
  }

  static updateProduct(id, data) {
    return HttpClient.put(`/products/${id}`, data)
  }

  static deleteProduct(id) {
    return HttpClient.delete(`/products/${id}`)
  }

  // ========== 地址 ==========
  static getAddresses() {
    return HttpClient.get('/addresses')
  }

  static createAddress(data) {
    return HttpClient.post('/addresses', data)
  }

  static parseAddress(text) {
    return HttpClient.post('/addresses/parse', { text })
  }

  // ========== 订单 ==========
  static getOrders(page = 1, pageSize = 10, status = null) {
    let url = `/orders?page=${page}&pageSize=${pageSize}`
    if (status) url += `&status=${status}`
    return HttpClient.get(url)
  }

  static createOrder(data) {
    return HttpClient.post('/orders', data)
  }

  // ========== 运费 ==========
  static calculateShipping(province, weight) {
    return HttpClient.post('/shipping/calculate', { province, weight })
  }
}

module.exports = ApiService
```

### 4. 页面改造示例

```javascript
// pages/index/index.js
const ApiService = require('../../utils/apiService.js')

Page({
  data: {
    riceProducts: []
  },

  async onLoad() {
    await this.loadProducts()
  },

  async loadProducts() {
    try {
      const products = await ApiService.getProducts()
      this.setData({
        riceProducts: products,
        isEmpty: products.length === 0
      })
    } catch (error) {
      console.error('加载商品失败', error)
      // 降级到本地存储
      this.loadLocalData()
    }
  }
})
```

---

## 总结

本设计方案提供了一个完整的 .NET 8 Minimal API 后端服务架构，包括：

✅ **技术选型**: .NET 8 Minimal API + PostgreSQL + Redis  
✅ **数据库设计**: 完整的表结构和索引设计  
✅ **API 设计**: RESTful API 规范，统一响应格式  
✅ **缓存策略**: Redis 缓存优化，提升性能  
✅ **部署方案**: Docker 和 Systemd 两种部署方式  
✅ **代码规范**: 清晰的开发规范和最佳实践  
✅ **小程序对接**: 详细的对接说明和示例代码

该方案具有以下特点：

1. **性能优异**: Minimal API + Redis 缓存，响应速度快
2. **易于部署**: Docker Compose 一键部署，环境一致性好
3. **易于维护**: 分层架构清晰，代码职责明确
4. **易于扩展**: 预留鉴权接口，支持后续功能扩展
5. **生产就绪**: 包含日志、健康检查、异常处理等完整功能

---

**文档版本**: v1.0  
**创建日期**: 2025年10月17日  
**适用版本**: .NET 8 + PostgreSQL 16 + Redis 7.2  
**维护状态**: ✅ 完整设计方案

---

© 2025 林龍香大米商城后端服务设计方案
