---
globs: *Repository.cs,*Service.cs
description: EF Core 数据访问模式和最佳实践
---

# EF Core 数据访问模式和最佳实践

## 全局配置

### NoTracking 配置
项目在 [Extensions/ServiceCollectionExtensions.cs](mdc:LLX.Server/Extensions/ServiceCollectionExtensions.cs) 中配置了全局 NoTracking：

```csharp
// 全局配置 NoTracking 提高查询性能
options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
```

**影响**: 所有查询默认不跟踪实体变化，提高查询性能。

## 更新操作模式

### 推荐方案：ExecuteUpdate (EF Core 8.0+)

由于项目使用 EF Core 8.0，优先使用 `ExecuteUpdate` 进行更新操作：

```csharp
// ✅ 推荐 - 最佳性能
public async Task<bool> UpdateStatusAsync(int id, string status)
{
    var affected = await _context.Orders
        .Where(o => o.Id == id)
        .ExecuteUpdateAsync(s => s
            .SetProperty(o => o.Status, status)
            .SetProperty(o => o.UpdatedAt, DateTime.UtcNow));
    
    return affected > 0;
}
```

**优势**:
- 只有 1 次数据库操作（UPDATE）
- 不需要先查询实体
- 类型安全，编译时检查
- 可以检查是否更新成功（通过 affected 行数）

### 备选方案：AsTracking

当需要复杂业务逻辑时，使用 `AsTracking()` 显式启用跟踪：

```csharp
// ⚠️ 备选 - 需要实体跟踪时使用
public async Task<bool> UpdateStatusAsync(int id, string status)
{
    var order = await _context.Orders
        .AsTracking() // 显式启用跟踪
        .FirstOrDefaultAsync(o => o.Id == id);
        
    if (order == null)
        return false;

    order.Status = status;
    order.UpdatedAt = DateTime.UtcNow;
    
    await _context.SaveChangesAsync();
    return true;
}
```

**使用场景**:
- 需要复杂的业务逻辑验证
- 需要访问实体的其他属性
- 需要触发实体的变更事件

## 查询操作模式

### 简单查询
```csharp
// ✅ 正确 - 利用全局 NoTracking
public async Task<Order?> GetByIdAsync(int id)
{
    return await _context.Orders
        .FirstOrDefaultAsync(o => o.Id == id);
}

// ✅ 正确 - 投影查询
public async Task<List<OrderDto>> GetAllOrdersAsync()
{
    return await _context.Orders
        .Select(o => new OrderDto
        {
            Id = o.Id,
            OrderNo = o.OrderNo,
            Status = o.Status
        })
        .ToListAsync();
}
```

### 复杂查询
```csharp
// ✅ 正确 - 包含关联数据
public async Task<Order?> GetOrderWithItemsAsync(int id)
{
    return await _context.Orders
        .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.Product)
        .FirstOrDefaultAsync(o => o.Id == id);
}

// ✅ 正确 - 条件查询
public async Task<List<Order>> GetOrdersByStatusAsync(string status)
{
    return await _context.Orders
        .Where(o => o.Status == status)
        .OrderByDescending(o => o.CreatedAt)
        .ToListAsync();
}
```

## 批量操作模式

### 批量插入
```csharp
// ✅ 正确 - 使用 AddRange
public async Task AddRangeAsync(IEnumerable<OrderItem> orderItems)
{
    _context.OrderItems.AddRange(orderItems);
    await _context.SaveChangesAsync();
}

// ❌ 错误 - 循环单个添加
public async Task AddRangeAsync(IEnumerable<OrderItem> orderItems)
{
    foreach (var item in orderItems)
    {
        _context.OrderItems.Add(item);
        await _context.SaveChangesAsync(); // 性能差
    }
}
```

### 批量更新
```csharp
// ✅ 正确 - 使用 ExecuteUpdate 批量更新
public async Task<int> UpdateOrdersStatusAsync(List<int> orderIds, string status)
{
    return await _context.Orders
        .Where(o => orderIds.Contains(o.Id))
        .ExecuteUpdateAsync(s => s
            .SetProperty(o => o.Status, status)
            .SetProperty(o => o.UpdatedAt, DateTime.UtcNow));
}
```

### 批量删除
```csharp
// ✅ 正确 - 使用 RemoveRange
public async Task<bool> DeleteAllAsync(List<int> ids)
{
    if (ids == null || !ids.Any())
        return false;

    var orders = await _context.Orders
        .Where(o => ids.Contains(o.Id))
        .ToListAsync();

    if (!orders.Any())
        return false;

    _context.Orders.RemoveRange(orders);
    await _context.SaveChangesAsync();
    return true;
}
```

## 事务处理

### 自动事务
```csharp
// ✅ 正确 - SaveChangesAsync 自动创建事务
public async Task<Order> CreateOrderAsync(CreateOrderDto createDto)
{
    var order = new Order
    {
        OrderNo = _orderNumberGenerator.Generate(),
        Status = createDto.Status
    };
    
    _context.Orders.Add(order);
    await _context.SaveChangesAsync(); // 自动事务
    
    // 添加订单明细
    var orderItems = createDto.Items.Select(item => new OrderItem
    {
        OrderId = order.Id,
        ProductId = item.ProductId,
        Quantity = item.Quantity
    });
    
    _context.OrderItems.AddRange(orderItems);
    await _context.SaveChangesAsync(); // 另一个事务
    
    return order;
}
```

### 显式事务
```csharp
// ✅ 正确 - 使用显式事务确保原子性
public async Task<Order> CreateOrderWithItemsAsync(CreateOrderDto createDto)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        var order = new Order
        {
            OrderNo = _orderNumberGenerator.Generate(),
            Status = createDto.Status
        };
        
        _context.Orders.Add(order);
        await _context.SaveChangesAsync();
        
        var orderItems = createDto.Items.Select(item => new OrderItem
        {
            OrderId = order.Id,
            ProductId = item.ProductId,
            Quantity = item.Quantity
        });
        
        _context.OrderItems.AddRange(orderItems);
        await _context.SaveChangesAsync();
        
        await transaction.CommitAsync();
        return order;
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }
}
```

## 性能优化模式

### 分页查询
```csharp
// ✅ 正确 - 高效分页
public async Task<PagedResult<Order>> GetOrdersPagedAsync(int pageNumber, int pageSize)
{
    var query = _context.Orders.AsNoTracking();
    
    var totalCount = await query.CountAsync();
    var orders = await query
        .OrderByDescending(o => o.CreatedAt)
        .Skip((pageNumber - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();
    
    return new PagedResult<Order>
    {
        Items = orders,
        TotalCount = totalCount,
        PageNumber = pageNumber,
        PageSize = pageSize
    };
}
```

### 查询优化
```csharp
// ✅ 正确 - 只查询需要的字段
public async Task<List<OrderSummaryDto>> GetOrderSummariesAsync()
{
    return await _context.Orders
        .Select(o => new OrderSummaryDto
        {
            Id = o.Id,
            OrderNo = o.OrderNo,
            Status = o.Status,
            TotalPrice = o.TotalRicePrice
        })
        .ToListAsync();
}

// ❌ 错误 - 查询所有字段
public async Task<List<Order>> GetOrderSummariesAsync()
{
    return await _context.Orders.ToListAsync(); // 查询所有字段
}
```

### 连接池优化
```csharp
// 在 Program.cs 中配置连接池
builder.Services.AddDbContext<AppDbContext>(options =>
{
    options.UseNpgsql(connectionString, npgsqlOptions =>
    {
        npgsqlOptions.EnableRetryOnFailure(
            maxRetryCount: 3,
            maxRetryDelay: TimeSpan.FromSeconds(30),
            errorCodesToAdd: null);
    });
    
    // 连接池配置
    options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
});
```

## 错误处理模式

### 数据库连接错误
```csharp
// ✅ 正确 - 处理连接错误
public async Task<Order?> GetByIdAsync(int id)
{
    try
    {
        return await _context.Orders
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    catch (SqlException ex) when (ex.Number == -2) // 超时
    {
        _logger.LogWarning("数据库查询超时，ID: {OrderId}", id);
        throw new TimeoutException("数据库查询超时", ex);
    }
    catch (SqlException ex)
    {
        _logger.LogError(ex, "数据库查询失败，ID: {OrderId}", id);
        throw;
    }
}
```

### 并发冲突处理
```csharp
// ✅ 正确 - 处理并发更新冲突
public async Task<bool> UpdateOrderAsync(int id, UpdateOrderDto updateDto)
{
    try
    {
        var affected = await _context.Orders
            .Where(o => o.Id == id)
            .ExecuteUpdateAsync(s => s
                .SetProperty(o => o.Status, updateDto.Status)
                .SetProperty(o => o.UpdatedAt, DateTime.UtcNow));
        
        return affected > 0;
    }
    catch (DbUpdateConcurrencyException ex)
    {
        _logger.LogWarning(ex, "订单更新冲突，ID: {OrderId}", id);
        return false; // 或者重试逻辑
    }
}
```

## 缓存集成模式

### 缓存穿透防护
```csharp
// ✅ 正确 - 使用缓存穿透防护
public async Task<Order?> GetByIdAsync(int id)
{
    var cacheKey = $"llxrice:order:{id}";
    
    return await _cacheService.GetOrSetAsync(cacheKey, async () =>
    {
        var order = await _context.Orders
            .FirstOrDefaultAsync(o => o.Id == id);
        
        // 如果订单不存在，缓存 null 值防止缓存穿透
        return order;
    }, TimeSpan.FromMinutes(30));
}
```

### 缓存失效策略
```csharp
// ✅ 正确 - 更新时清除相关缓存
public async Task<bool> UpdateStatusAsync(int id, string status)
{
    var affected = await _context.Orders
        .Where(o => o.Id == id)
        .ExecuteUpdateAsync(s => s
            .SetProperty(o => o.Status, status)
            .SetProperty(o => o.UpdatedAt, DateTime.UtcNow));
    
    if (affected > 0)
    {
        // 清除相关缓存
        await _cacheService.RemoveAsync($"llxrice:order:{id}");
        await _cacheService.RemoveByPatternAsync("llxrice:order:all*");
    }
    
    return affected > 0;
}
```

## 常见陷阱和解决方案

### 陷阱1：忘记使用 AsTracking
```csharp
// ❌ 错误 - 全局 NoTracking 导致更新失败
public async Task<bool> UpdateStatusAsync(int id, string status)
{
    var order = await _context.Orders
        .FirstOrDefaultAsync(o => o.Id == id); // 没有 AsTracking
    
    if (order == null)
        return false;

    order.Status = status; // 修改不会被跟踪
    await _context.SaveChangesAsync(); // 不会生成 UPDATE SQL
    return true;
}

// ✅ 解决 - 使用 ExecuteUpdate 或 AsTracking
public async Task<bool> UpdateStatusAsync(int id, string status)
{
    var affected = await _context.Orders
        .Where(o => o.Id == id)
        .ExecuteUpdateAsync(s => s
            .SetProperty(o => o.Status, status)
            .SetProperty(o => o.UpdatedAt, DateTime.UtcNow));
    
    return affected > 0;
}
```

### 陷阱2：N+1 查询问题
```csharp
// ❌ 错误 - N+1 查询
public async Task<List<OrderDto>> GetOrdersWithItemsAsync()
{
    var orders = await _context.Orders.ToListAsync();
    
    foreach (var order in orders)
    {
        order.OrderItems = await _context.OrderItems
            .Where(oi => oi.OrderId == order.Id)
            .ToListAsync(); // N+1 查询
    }
    
    return _mapper.Map<List<OrderDto>>(orders);
}

// ✅ 解决 - 使用 Include
public async Task<List<OrderDto>> GetOrdersWithItemsAsync()
{
    var orders = await _context.Orders
        .Include(o => o.OrderItems)
        .ToListAsync();
    
    return _mapper.Map<List<OrderDto>>(orders);
}
```

### 陷阱3：内存泄漏
```csharp
// ❌ 错误 - 可能导致内存泄漏
public async Task<List<Order>> GetAllOrdersAsync()
{
    return await _context.Orders
        .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.Product)
        .ToListAsync(); // 加载所有数据到内存
}

// ✅ 解决 - 使用分页或投影
public async Task<List<OrderSummaryDto>> GetOrderSummariesAsync()
{
    return await _context.Orders
        .Select(o => new OrderSummaryDto
        {
            Id = o.Id,
            OrderNo = o.OrderNo,
            Status = o.Status,
            ItemCount = o.OrderItems.Count
        })
        .ToListAsync();
}
```